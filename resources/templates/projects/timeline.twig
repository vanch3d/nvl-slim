{% extends 'site.twig' %}

{% block urltile %}Research Projects (Timeline){% endblock %}
{% block pagetile %}Research Projects{% endblock %}

{% block breadcrumb %}
    <ol class="breadcrumb">
        <li><a title="Home" href="{{ path_for('home') }}">Home</a></li>
        <li><a title="Home" href="{{ path_for('project.all') }}">Projects</a></li>
        <li class="active">Timeline</li>
    </ol>
{% endblock %}

{% block pagedescription %}
    <h2>Research Projects - Timeline</h2>

{% endblock %}


{% block content %}
    <section class="section">
        <div class="container-fluid">
            <div class="row">
                <div class="col-md-12">
                    <div id="tl-container" style="width: 100%; height: 680px;">
                    </div>
                </div>
            </div>
        </div>
    </section>


{% endblock %}

{% block injectCSS %}
    <style>
    </style>
{% endblock %}

{% block injectJS %}
<script type="text/javascript" src="/js/d3.nvl-bundle.min.js"></script>
<script type="text/javascript" src="/js/timeline.min.js"></script>
<script type="text/javascript" src="/js/TL.Media.GitHub.min.js"></script>
<script type="text/javascript">

    var jNVL = (function (self,$) {

        function _initTimelineJS3() {
            console.log("TL: Overriding MediaType factory");
            // Override MediaType to include our own types
            // @todo[vanch3d] Is there a better way?
            var oldMediaType = TL.MediaType.prototype;
            TL.MediaType = function(m, image_only){
                var media = {},
                    media_types =     [
                        {
                            type:         "github",
                            name:         "github",
                            match_str:     "^(https?:)?\/*(api.)?github.com",
                            cls:         TL.Media.GitHub
                        }];

                for (var i = 0; i < media_types.length; i++) {
                    if (m.url.match(media_types[i].match_str)) {
                        media         = media_types[i];
                        return media;
                    }

                }

                return oldMediaType.constructor(m,image_only);
            };

            console.log("TL: Overriding menu bar");
            // overriding timeline's menu bar to add the fullscreen button
            TL.MenuBar.prototype._initLayout = function()
            {
                // Create Layout
                this._el.button_fulscreen 				    	= TL.Dom.create('span', 'tl-menubar-button', this._el.container);
                this._el.button_zoomin 							= TL.Dom.create('span', 'tl-menubar-button', this._el.container);
                this._el.button_zoomout 						= TL.Dom.create('span', 'tl-menubar-button', this._el.container);
                this._el.button_backtostart 					= TL.Dom.create('span', 'tl-menubar-button', this._el.container);

                if (TL.Browser.mobile) {
                    this._el.container.setAttribute("ontouchstart"," ");
                }

                this._el.button_fulscreen.innerHTML		    = "<span id='btn-fullscreen'><i class='fa fa-window-maximize'></i></span>";
                this._el.button_backtostart.innerHTML		= "<span class='tl-icon-goback'></span>";
                this._el.button_zoomin.innerHTML			= "<span class='tl-icon-zoom-in'></span>";
                this._el.button_zoomout.innerHTML			= "<span class='tl-icon-zoom-out'></span>";
            };

        }

        function _createProjectEvent(project) {
            var start = new Date(project.start);
            var end = new Date(project.end);

            return {
                start_date: {
                    year: start.getFullYear(),
                    month: start.getMonth()
                },
                end_date: {
                    year: end.getFullYear(),
                    month: end.getMonth()
                },
                text: {
                    headline: project.title,
                    text: project.description
                },
                unique_id: project.id,
                group: "Projects",
                media: {
                    url: "/images/project.png",
                    caption: "HELLO",
                    thumbnail: "/images/project.png"
                },
                background: {
                    url: null,
                    color: null
                }
            };

        }

        function _createPublicationEvent(publication) {

            return {
                start_date: {
                    year: publication.issued["date-parts"][0][0],
                    month: publication.issued["date-parts"][0][1] || null
                },
                text: {
                    headline: publication.archive_location,
                    text: publication.abstract || ""
                },
                unique_id: publication.project.id + "-" + publication.archive_location,
                group: "Publications"
            };
        }

        function _createGitHubEvent(repo) {
            var created = new Date(repo.created_at);

            return {
                start_date: {
                    year: created.getFullYear(),
                    month: created.getMonth()
                },
                media: {
                    url: repo.url,
                    github: repo
                },
                //text: { headline: repo.tag_name, text: repo.body || ""},
                unique_id: repo.project + "-" + repo.tag_name + "-marker",
                group: "Source Code"
            };
        }

        function _initProjectColors(projects) {
            // no css for individual marker so tricking it with id patterns
            var cb = colorbrewer.Set3[projects.length];
            $.each(projects,function(idx,id){
                var sel= "div.tl-timemarker[id*='"+id+"'] .tl-timemarker-content-container";
                $(sel).css("background-color",cb[idx]);
            });
            return cb;
        }

        self.createProjectTimeline = function (containerId) {
            _initTimelineJS3();

            // data stub for the timeline
            var tl_json = {
                events : [] ,
                title: {
                    text: { headline: "Research & Development Activities"}
                },
                eras: []
            };

            // list of project id
            var prj_list = [];

            // Wrangle the different sources of data (projects, publications, github, images)
            // @todo[vanch3d] tried d3.queue to get all requests in one pass, but not working. Try $.when ?
            var q = d3.queue();

            // First stage : get the projects and publications
            q.defer(function(c) {
                $.getJSON("{{ path_for('api.projects') }}").done(function (src) { c(null,src.data);})
            });
            q.defer(function(c) {
                $.getJSON("{{ path_for('api.publications') }}").done(function (src) { c(null,src.data);})
            });

            // wait for both request to finish
            q.await(function(error,projects,publications) {
                if (error) throw error;

                // computing eras from projects
                var currentEra = {
                    start_date: { year: null },
                    end_date: { year: "1994" },
                    text: { headline: null, text: null}
                };

                // initialing second queue for other conditional requests
                q = d3.queue();
                $.each( projects.reverse(), function( index, project){

                    // Add the projects to the timeline
                    var event = _createProjectEvent(project);
                    tl_json.events.push(event);
                    prj_list.push(project.id);


                    // create an era based on project and previous era
                    var era = {
                        start_date: currentEra.end_date,
                        end_date: event.end_date,
                        text: { headline: project.location, text: project.institution}
                    };

                    // check if we are at same location
                    if (era.text.headline !== currentEra.text.headline) {
                        if (currentEra.text.headline != null) tl_json.eras.push(currentEra);
                        currentEra = era;
                    }
                    else
                    {
                        currentEra.end_date = event.end_date;
                    }

                    // extract publications for this project
                    var projectPubs = $.grep(publications,function(pub,idx){
                        return (pub.project.id === project.id);
                    });

                    // Add the project's publications to the timeline
                    $.each( projectPubs, function( index, pub ){
                        var event = _createPublicationEvent(pub);
                        tl_json.events.push(event);
                    });

                    // Second stage : get the github releases from the project
                    $.each( project.github, function( index, repos){
                        if (repos === "") return;

                        //var Etag = localStorage.getItem("nvl-slim.github.request." + repos);
                        var headers = {
                        };

                        q.defer(function(c) {
                            $.ajax({
                                dataType: "json",
                                headers: headers,
                                url: "https://api.github.com/repos/" + repos + "/releases"
                            }).done(function (src) {
                                // insert project id in github data
                                $.each( src, function(index){ src[index]['project'] = project.id; });
                                c(null,src);});
                        });
                    });
                });
                if (currentEra.text.headline != null) tl_json.eras.push(currentEra);

                // wait for all github requests to finish
                q.awaitAll(function(error,data){
                    if (error) throw error;

                    // flatten the list
                    var allRepos = [];
                    $.each( data, function( index, repo ){ $.merge(allRepos,repo); });

                    // Add the repo to the timeline (using the GitHub custom MediaType
                    $.each( allRepos, function( index, repo ){
                        var event = _createGitHubEvent(repo);
                        tl_json.events.push(event);
                    });

                    // create the timeline
                    var timeline = new TL.Timeline(containerId,tl_json);
                    $("#btn-fullscreen").click(function()
                    {
                        $("#"+containerId).toggleFullScreen();
                    });

                    _initProjectColors(prj_list);

                    return timeline;

                })
            });

        };


        return self;

    }( jNVL || {}, jQuery ));


    $(document).ready(function () {

        jNVL.createProjectTimeline('tl-container');

    });
</script>
{% endblock %}
